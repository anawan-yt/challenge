<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Anawan - 1 abonné = 1 ligne de code</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#29adff" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.80.1/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        background-color: #29adff;
      }
    </style>
  </head>
  <body>
    <script>
      // Globales
      const PLAYER_VELOCITY = 240
      const PLAYER_BOUNCE_OFF_VELOCITY = 400
      const PLAYER_MIN_JUMP_VELOCITY = -360
      const PLAYER_MAX_JUMP_VELOCITY = -400
      const PLAYER_MAX_JUMP_TIME = 150
      const PLAYER_BUFFERING_TIME = 200
      const PLAYER_COYOTE_TIME = 200
      const PLAYER_MAX_JUMPS = 2
      const PLAYER_DEATH_JUMP_X = 100
      const PLAYER_DEATH_JUMP_Y = -600
      const PLAYER_FALL_SQUASH_VELOCITY = 700
      const ENEMY_VELOCITY = 140
      const NUM_LEVELS = 8

      const levelsData = {
        level1: {
          world: { width: 2920, height: 540 },
          player: { x: 80, y: 320 },
          target: { x: 2860, y: 240 },
          hills: [
            { x: 200, y: 200 },
            { x: 360, y: 240 },
            { x: 800, y: 240 },
            { x: 1000, y: 200 },
            { x: 1600, y: 200 },
          ],
          hillsFront: [
            { x: 10, y: 340 },
            { x: 700, y: 380 },
            { x: 800, y: 420 },
            { x: 1300, y: 380 },
            { x: 1600, y: 420 },
          ],
          clouds: {
            y: { min: 60, max: 180 },
            x: [-100, 400, 900, 1440, 1600, 2000],
          },
          platforms: [
            { x: 0, y: 500, width: 400, height: 40 },
            { x: 400, y: 460, width: 400, height: 80 },
            { x: 920, y: 460, width: 240, height: 80 },
            { x: 1160, y: 500, width: 1760, height: 40 },
            { x: 1800, y: 460, width: 40, height: 40 },
            { x: 1840, y: 420, width: 40, height: 80 },
            { x: 2300, y: 420, width: 40, height: 80 },
            { x: 2340, y: 460, width: 40, height: 40 },
            { x: 2580, y: 380, width: 120, height: 40 },
            { x: 2800, y: 280, width: 120, height: 40 },
          ],
          enemies: [{ x: 2000, y: 480 }],
          spikes: [
            { x: 1360, y: 460 },
            { x: 1400, y: 460 },
            { x: 1580, y: 460 },
          ],
        },
        level2: {
          world: { width: 3400, height: 1080 },
          player: { x: 80, y: 700 },
          target: { x: 3280, y: 640 },
          hills: [
            { x: -300, y: 200 },
            { x: 360, y: 240 },
            { x: 500, y: 180 },
            { x: 1000, y: 100 },
          ],
          hillsFront: [
            { x: -160, y: 380 },
            { x: 400, y: 480 },
            { x: 1400, y: 300 },
          ],
          clouds: {
            y: { min: 500, max: 620 },
            x: [-100, 400, 900, 1440, 1600, 2000],
          },
          platforms: [
            { x: 0, y: 880, width: 600, height: 200 },
            { x: 720, y: 880, width: 80, height: 200 },
            { x: 920, y: 880, width: 80, height: 200 },
            { x: 1120, y: 960, width: 80, height: 120 },
            { x: 1200, y: 1040, width: 400, height: 40 },
            { x: 1600, y: 960, width: 200, height: 120 },
            { x: 1800, y: 1040, width: 160, height: 40 },
            { x: 1960, y: 960, width: 160, height: 120 },
            { x: 2120, y: 880, width: 160, height: 200 },
            { x: 2280, y: 800, width: 160, height: 280 },
            { x: 2440, y: 680, width: 160, height: 400 },
            { x: 2680, y: 1040, width: 80, height: 40 },
            { x: 2840, y: 0, width: 80, height: 880 },
            { x: 2840, y: 1040, width: 560, height: 40 },
            { x: 3120, y: 680, width: 280, height: 400 },
            { x: 3080, y: 920, width: 40, height: 40 },
            { x: 2920, y: 800, width: 40, height: 40 },
            { x: 3080, y: 680, width: 40, height: 40 },
          ],
          enemies: [
            { x: 1400, y: 980 },
            { x: 1400, y: 980, dir: -1 },
          ],
          spikes: [
            { x: 1800, y: 1000 },
            { x: 1840, y: 1000 },
            { x: 1880, y: 1000 },
            { x: 1920, y: 1000 },
            { x: 2600, y: 1040 },
            { x: 2640, y: 1040 },
            { x: 2760, y: 1040 },
            { x: 2800, y: 1040 },
          ],
          fallingBlocks: [
            { x: 1800, y: 960 },
            { x: 1840, y: 960 },
            { x: 1880, y: 960 },
            { x: 1920, y: 960 },
            { x: 2600, y: 680 },
            { x: 2640, y: 680 },
            { x: 2680, y: 680 },
            { x: 2720, y: 680 },
            { x: 2760, y: 680 },
            { x: 2800, y: 680 },
            { x: 2600, y: 840 },
            { x: 2640, y: 840 },
            { x: 2680, y: 840 },
            { x: 2720, y: 840 },
            { x: 2760, y: 840 },
            { x: 2800, y: 840 },
          ],
        },
        level3: {
          world: { width: 4040, height: 1080 },
          player: { x: 80, y: 760 },
          target: { x: 2680, y: 160 },
          hills: [
            { x: -340, y: 200 },
            { x: 360, y: 240 },
            { x: 500, y: 180 },
            { x: 1000, y: 100 },
          ],
          hillsFront: [
            { x: 0, y: 380 },
            { x: 300, y: 400 },
            { x: 1000, y: 300 },
          ],
          clouds: {
            y: { min: 400, max: 520 },
            x: [-100, 200, 740, 1440, 1600, 2000],
          },
          platforms: [
            { x: 0, y: 880, width: 400, height: 200 },
            { x: 400, y: 760, width: 200, height: 320 },
            { x: 600, y: 680, width: 200, height: 400 },
            { x: 800, y: 840, width: 480, height: 240 },
            { x: 1280, y: 680, width: 200, height: 400 },
            { x: 1480, y: 880, width: 280, height: 200 },
            { x: 1640, y: 0, width: 120, height: 720 },
            { x: 1640, y: 960, width: 600, height: 120 },
            { x: 1760, y: 240, width: 1440, height: 360 },
            { x: 2240, y: 880, width: 120, height: 200 },
            { x: 3080, y: 880, width: 680, height: 200 },
            { x: 3200, y: 240, width: 120, height: 520 },
            { x: 3760, y: 0, width: 280, height: 1080 },
            { x: 1760, y: 0, width: 840, height: 240 },
          ],
          oneWayPlatforms: [
            { x: 0, y: 760, width: 400 },
            {
              x: 800,
              y: 690,
              width: 120,
              points: [{ x: 1160, y: 690 }],
            },
            {
              x: 2360,
              y: 890,
              width: 120,
              points: [{ x: 2560, y: 890 }],
            },
            {
              x: 2960,
              y: 890,
              width: 120,
              points: [{ x: 2760, y: 890 }],
            },
            { x: 3320, y: 740, width: 440 },
            {
              x: 3320,
              y: 620,
              width: 120,
              points: [{ x: 3640, y: 620 }],
            },
            {
              x: 3640,
              y: 500,
              width: 120,
              points: [{ x: 3320, y: 500 }],
            },
            {
              x: 3320,
              y: 380,
              width: 120,
              points: [{ x: 3640, y: 380 }],
            },
            { x: 3320, y: 240, width: 440 },
          ],
          enemies: [{ x: 1720, y: 940 }],
          spikes: [
            { x: 560, y: 720 },
            { x: 800, y: 800 },
            { x: 840, y: 800 },
            { x: 880, y: 800 },
            { x: 920, y: 800 },
            { x: 960, y: 800 },
            { x: 1000, y: 800 },
            { x: 1040, y: 800 },
            { x: 1080, y: 800 },
            { x: 1120, y: 800 },
            { x: 1160, y: 800 },
            { x: 1200, y: 800 },
            { x: 1240, y: 800 },
            { x: 1480, y: 840 },
            { x: 1520, y: 840 },
            { x: 3280, y: 200 },
            { x: 3240, y: 200 },
          ],
          fallingBlocks: [
            { x: 1480, y: 680 },
            { x: 1520, y: 680 },
            { x: 1560, y: 680 },
            { x: 1600, y: 680 },
          ],
        },
        level4: {
          world: { width: 2400, height: 2400 },
          player: { x: 400, y: 2240 },
          target: { x: 1320, y: 2160 },
          checkpoint: { x: 480, y: 540 },
          hills: [
            { x: 0, y: 400 },
            { x: 880, y: 320 },
          ],
          hillsFront: [{ x: 400, y: 860 }],
          clouds: {
            y: { min: 200, max: 320 },
            x: [-100, 200, 740, 1440, 1600, 2000],
          },
          platforms: [
            { x: 0, y: 0, width: 200, height: 2400 },
            { x: 200, y: 2280, width: 2000, height: 120 },
            { x: 1160, y: 640, width: 80, height: 1640 },
            { x: 760, y: 2200, width: 200, height: 80 },
            { x: 960, y: 2120, width: 200, height: 160 },
            { x: 200, y: 1960, width: 760, height: 40 },
            { x: 200, y: 1960, width: 760, height: 40 },
            { x: 200, y: 1800, width: 200, height: 160 },
            { x: 400, y: 1880, width: 200, height: 80 },
            { x: 400, y: 1640, width: 760, height: 40 },
            { x: 600, y: 1560, width: 80, height: 80 },
            { x: 200, y: 1200, width: 760, height: 40 },
            { x: 880, y: 840, width: 80, height: 360 },
            { x: 880, y: 640, width: 80, height: 80 },
            { x: 200, y: 1120, width: 200, height: 80 },
            { x: 400, y: 600, width: 1640, height: 40 },
            { x: 2200, y: 0, width: 200, height: 2400 },
            { x: 600, y: 560, width: 40, height: 40 },
            { x: 760, y: 520, width: 40, height: 80 },
            { x: 920, y: 480, width: 40, height: 120 },
            { x: 1440, y: 480, width: 40, height: 120 },
            { x: 1400, y: 1200, width: 800, height: 40 },
            { x: 1640, y: 960, width: 80, height: 240 },
            { x: 1240, y: 1960, width: 760, height: 40 },
            { x: 1240, y: 1480, width: 120, height: 480 },
            { x: 1480, y: 1600, width: 120, height: 360 },
            { x: 1720, y: 1720, width: 120, height: 240 },
            { x: 1960, y: 1720, width: 40, height: 240 },
          ],
          oneWayPlatforms: [
            { x: 960, y: 1960, width: 200 },
            { x: 200, y: 1640, width: 200 },
            {
              x: 680,
              y: 1480,
              width: 120,
              points: [{ x: 1040, y: 1480 }],
            },
            {
              x: 1040,
              y: 1360,
              width: 120,
              points: [{ x: 680, y: 1360 }],
            },
            { x: 960, y: 1200, width: 200 },
            {
              x: 1000,
              y: 1120,
              width: 120,
              points: [{ x: 1000, y: 880 }],
            },
            {
              x: 480,
              y: 1020,
              width: 120,
              points: [{ x: 720, y: 1020 }],
            },
            {
              x: 240,
              y: 980,
              width: 120,
              points: [{ x: 240, y: 740 }],
            },
            { x: 200, y: 600, width: 200 },
          ],
          enemies: [
            { x: 240, y: 1600 },
            { x: 1200, y: 560 },
            { x: 1200, y: 560, dir: -1 },
            { x: 2120, y: 1920 },
          ],
          spikes: [
            { x: 1120, y: 1920 },
            { x: 920, y: 1920 },
            { x: 880, y: 1920 },
            { x: 560, y: 1840 },
            { x: 400, y: 1840 },
            { x: 200, y: 1760 },
            { x: 680, y: 1600 },
            { x: 720, y: 1600 },
            { x: 760, y: 1600 },
            { x: 800, y: 1600 },
            { x: 840, y: 1600 },
            { x: 880, y: 1600 },
            { x: 920, y: 1600 },
            { x: 960, y: 1600 },
            { x: 1000, y: 1600 },
            { x: 1040, y: 1600 },
            { x: 1080, y: 1600 },
            { x: 1120, y: 1600 },
            { x: 840, y: 1160 },
            { x: 800, y: 1160 },
            { x: 760, y: 1160 },
            { x: 720, y: 1160 },
            { x: 680, y: 1160 },
            { x: 640, y: 1160 },
            { x: 600, y: 1160 },
            { x: 560, y: 1160 },
            { x: 520, y: 1160 },
            { x: 480, y: 1160 },
            { x: 440, y: 1160 },
            { x: 400, y: 1160 },
            { x: 640, y: 560 },
            { x: 680, y: 560 },
            { x: 720, y: 560 },
            { x: 800, y: 560 },
            { x: 840, y: 560 },
            { x: 880, y: 560 },
            { x: 2160, y: 1160 },
            { x: 2120, y: 1160 },
            { x: 2080, y: 1160 },
            { x: 2040, y: 1160 },
            { x: 2000, y: 1160 },
            { x: 1960, y: 1160 },
            { x: 1920, y: 1160 },
            { x: 1880, y: 1160 },
            { x: 1840, y: 1160 },
            { x: 1800, y: 1160 },
            { x: 1760, y: 1160 },
            { x: 1720, y: 1160 },
            { x: 1680, y: 920 },
            { x: 1640, y: 920 },
            { x: 1600, y: 1160 },
            { x: 1560, y: 1160 },
            { x: 1520, y: 1160 },
            { x: 1480, y: 1160 },
            { x: 1440, y: 1160 },
            { x: 1400, y: 1160 },
            { x: 1360, y: 1920 },
            { x: 1400, y: 1920 },
            { x: 1440, y: 1920 },
            { x: 1600, y: 1920 },
            { x: 1640, y: 1920 },
            { x: 1680, y: 1920 },
            { x: 1840, y: 1920 },
            { x: 1880, y: 1920 },
            { x: 1920, y: 1920 },
          ],
          spikyBalls: [
            { x: 640, y: 960 },
            { x: 200, y: 480 },
            { x: 240, y: 480 },
            { x: 280, y: 480 },
            { x: 320, y: 480 },
            { x: 360, y: 480 },
            { x: 1600, y: 480 },
            { x: 1720, y: 560 },
            { x: 1840, y: 480 },
            { x: 1960, y: 560 },
            { x: 1400, y: 1440 },
            { x: 1640, y: 1560 },
            { x: 1880, y: 1680 },
            { x: 1880, y: 2240 },
            { x: 1880, y: 2200 },
            { x: 1880, y: 2160 },
            { x: 1880, y: 2000 },
            { x: 1680, y: 2240 },
            { x: 1680, y: 2080 },
            { x: 1680, y: 2040 },
            { x: 1680, y: 2000 },
            { x: 1480, y: 2240 },
            { x: 1480, y: 2200 },
            { x: 1480, y: 2040 },
            { x: 1480, y: 2000 },
          ],
          fallingBlocks: [
            { x: 2040, y: 600 },
            { x: 2080, y: 600 },
            { x: 2120, y: 600 },
            { x: 2160, y: 600 },
            { x: 2080, y: 800 },
            { x: 2120, y: 800 },
            { x: 2160, y: 1000 },
            { x: 2120, y: 1000 },
            { x: 2080, y: 1000 },
            { x: 2040, y: 1000 },
            { x: 2000, y: 1000 },
            { x: 1960, y: 1000 },
            { x: 2000, y: 1000 },
            { x: 1960, y: 1000 },
            { x: 1840, y: 1000 },
            { x: 1800, y: 1000 },
            { x: 1520, y: 1000 },
            { x: 1480, y: 1000 },
            { x: 1240, y: 1200 },
            { x: 1280, y: 1200 },
            { x: 1320, y: 1200 },
            { x: 1360, y: 1200 },
            { x: 2000, y: 1720 },
            { x: 2040, y: 1720 },
            { x: 2080, y: 1720 },
            { x: 2120, y: 1720 },
            { x: 2160, y: 1720 },
            { x: 2000, y: 1960 },
            { x: 2040, y: 1960 },
            { x: 2080, y: 1960 },
            { x: 2120, y: 1960 },
            { x: 2160, y: 1960 },
          ],
        },
      }

      const transitionEventsEmitter = new Phaser.Events.EventEmitter()

      function stringifyTime(elapsed) {
        const minutes = Math.floor(elapsed / 60000)
        const seconds = Math.floor((elapsed % 60000) / 1000)
        const centiseconds = Math.floor(elapsed % 1000)
        return (
          Phaser.Utils.String.Pad(minutes, 2, '0', 1) +
          "'" +
          Phaser.Utils.String.Pad(seconds, 2, '0', 1) +
          '"' +
          Phaser.Utils.String.Pad(centiseconds, 3, '0', 1)
        )
      }

      function getUnlockedLevels() {
        const unlockedLevelsString = localStorage.getItem('unlockedLevels')
        if (unlockedLevelsString) {
          return JSON.parse(unlockedLevelsString)
        } else {
          const level = {
            level: 1,
            time: 0,
          }
          localStorage.setItem('unlockedLevels', JSON.stringify([level]))
          return [level]
        }
      }

      function getLevelInfo(levelNum) {
        const unlockedLevels = getUnlockedLevels()
        return unlockedLevels.find(({ level }) => level === levelNum)
      }

      function updateLevelInfo(levelNum, data) {
        const unlockedLevels = getUnlockedLevels()
        const index = unlockedLevels.findIndex(({ level }) => level === levelNum)
        if (index === -1) return

        unlockedLevels[index] = { ...unlockedLevels[index], ...data }
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function unlockLevel(levelNum, time = 0) {
        const unlockedLevels = getUnlockedLevels()
        if (unlockedLevels.some(({ level }) => level === levelNum)) return

        unlockedLevels.push({
          level: levelNum,
          time,
        })
        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function unlockAllLevels() {
        let unlockedLevels = getUnlockedLevels()
        const unlockedLevelSet = new Set(unlockedLevels.map((levelData) => levelData.level))
        for (let level = 1; level <= Object.keys(levelsData).length; level++) {
          if (!unlockedLevelSet.has(level)) {
            unlockedLevels.push({ level, time: 0 })
          }
        }

        localStorage.setItem('unlockedLevels', JSON.stringify(unlockedLevels))
      }

      function resetBestTimes() {
        const unlockedLevels = getUnlockedLevels()
        const resetTimesLevels = unlockedLevels.map((level) => ({ ...level, time: 0 }))
        localStorage.setItem('unlockedLevels', JSON.stringify(resetTimesLevels))
      }

      class PreloaderScene extends Phaser.Scene {
        constructor() {
          super({ key: 'preloader' })
        }

        preload() {
          this.load.setBaseURL('assets')

          this.load.audio('music', 'audio/music.mp3')
          this.load.audio('sfxJump', 'audio/sfx-jump.mp3')
          this.load.audio('sfxHit', 'audio/sfx-hit.mp3')
          this.load.audio('sfxDeath', 'audio/sfx-death.mp3')
          this.load.audio('sfxWin', 'audio/sfx-win.mp3')
          this.load.audio('sfxCheckpoint', 'audio/sfx-checkpoint.mp3')

          const { width, height } = this.scale
          const text = this.add
            .text(width / 2, height / 2 - 24, 'Chargement...', { fontSize: '24px', fill: '#1d2b53' })
            .setOrigin(0.5, 0.5)

          const progressBox = this.add.graphics()
          progressBox.lineStyle(4, 0x1d2b53)
          progressBox.strokeRect(width / 2 - 102, height / 2, 204, 40)

          this.progressBar = this.add.graphics()
          this.load.on('progress', this.onProgress, this)
        }

        create() {
          this.scene.start('intro')
        }

        onProgress(val) {
          const { width, height } = this.scale
          const [progressWidth, progressHeight] = [200, 38]

          this.progressBar.clear()
          this.progressBar.fillStyle(0x1d2b53, 1)
          this.progressBar.fillRect(width / 2 - progressWidth / 2, height / 2, progressWidth * val, progressHeight)
        }
      }

      class SettingsScene extends Phaser.Scene {
        constructor() {
          super({ key: 'settings' })
        }

        create() {
          const btnBack = this.add.sprite(40, 40, 'btnBack')
          btnBack.setInteractive()
          btnBack.on('pointerdown', this.goBack, this)

          const btnModeBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          this.btnModeText = this.add.text(0, 0, this.getModeText(), { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(this.btnModeText, btnModeBg)
          const btnMode = this.add.container(480, 120, [btnModeBg, this.btnModeText])
          btnMode.setSize(360, 80)
          btnMode.setInteractive()
          btnMode.on('pointerdown', this.handleChangeMode, this)

          const btnSoundBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          this.btnSoundText = this.add.text(0, 0, this.getMuteStateText(), { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(this.btnSoundText, btnSoundBg)
          const btnSound = this.add.container(480, 220, [btnSoundBg, this.btnSoundText])
          btnSound.setSize(360, 80)
          btnSound.setInteractive()
          btnSound.on('pointerdown', this.handleToggleSound, this)

          const btnUnlockBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          const btnUnlockText = this.add.text(0, 0, 'Débloquer les niveaux', { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(btnUnlockText, btnUnlockBg)
          const btnUnlock = this.add.container(480, 320, [btnUnlockBg, btnUnlockText])
          btnUnlock.setSize(360, 80)
          btnUnlock.setInteractive()
          btnUnlock.on('pointerdown', unlockAllLevels)

          const btnResetTimesBg = this.add.rectangle(0, 0, 360, 80, 0xffffff)
          const btnResetTimesText = this.add.text(0, 0, 'Reset meilleurs temps', { fontSize: '24px', fill: '#1d2b53' })
          Phaser.Display.Align.In.Center(btnResetTimesText, btnResetTimesBg)
          const btnResetTimes = this.add.container(480, 420, [btnResetTimesBg, btnResetTimesText])
          btnResetTimes.setSize(360, 80)
          btnResetTimes.setInteractive()
          btnResetTimes.on('pointerdown', resetBestTimes)

          this.scene.launch('transition')
        }

        getModeText() {
          const mode = this.registry.get('mode')
          return `Mode : ${mode === 'classic' ? 'Classique' : 'Speedrun'}`
        }

        getMuteStateText() {
          const isMute = this.registry.get('mute')
          return `Musique : ${isMute ? 'Non' : 'Oui'}`
        }

        handleChangeMode() {
          let mode = this.registry.get('mode')
          mode = mode === 'classic' ? 'speedrun' : 'classic'
          this.registry.set('mode', mode)
          localStorage.setItem('mode', mode)
          this.btnModeText.setText(this.getModeText())
        }

        goBack() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('intro'), this)
        }

        handleToggleSound() {
          this.scene.get('audio').toggleMute()
          this.btnSoundText.setText(this.getMuteStateText())
        }
      }

      class AudioScene extends Phaser.Scene {
        constructor() {
          super({ key: 'audio' })
        }

        create() {
          const isMute = JSON.parse(localStorage.getItem('mute')) || false
          this.registry.set('mute', isMute)
          this.sound.mute = isMute

          if (!this.sound.get('music')) {
            this.backgroundMusic = this.sound.add('music', {
              loop: true,
            })
            this.playMusic()

            const sfxJump = this.sound.add('sfxJump', { volume: 0.5 })
            const sfxHit = this.sound.add('sfxHit')
            const sfxDeath = this.sound.add('sfxDeath')
            const sfxWin = this.sound.add('sfxWin')
            const sfxCheckpoint = this.sound.add('sfxCheckpoint')

            this.sfx = {
              sfxJump,
              sfxHit,
              sfxDeath,
              sfxWin,
              sfxCheckpoint,
            }
          }
        }

        playSfx(key) {
          this.sfx[key]?.play()
        }

        playMusic() {
          this.backgroundMusic.play()
        }

        pauseMusic() {
          this.backgroundMusic.pause()
        }

        toggleMute() {
          const isMute = this.registry.get('mute')
          this.sound.mute = !isMute
          this.registry.set('mute', !isMute)
          localStorage.setItem('mute', !isMute)
        }
      }

      class TransitionScene extends Phaser.Scene {
        constructor() {
          super({ key: 'transition' })
        }

        init(data) {
          this.isOpen = data.isOpen ?? false
        }

        create() {
          this.scene.bringToTop()
          const { width, height } = this.scale

          this.rect1 = this.add.rectangle(0, this.isOpen ? -height / 2 : 0, width, height / 2, 0x1d2b53)
          this.rect1.setOrigin(0, 0)
          this.rect2 = this.add.rectangle(0, this.isOpen ? height : height / 2, width, height / 2, 0x1d2b53)
          this.rect2.setOrigin(0, 0)

          transitionEventsEmitter.off('start', this.startTransition, this)
          transitionEventsEmitter.on('start', this.startTransition, this)

          this.startTransition()
        }

        startTransition() {
          if (this.isOpen) {
            this.input.keyboard.manager.enabled = false
            this.input.mouse.enabled = false
          }

          const { width, height } = this.scale

          this.tweens.add({
            targets: this.rect1,
            y: this.isOpen ? 0 : -height / 2,
            duration: 500,
            ease: 'Cubic.Out',
          })

          this.tweens.add({
            targets: this.rect2,
            y: this.isOpen ? height / 2 : height,
            duration: 500,
            ease: 'Cubic.Out',
            onComplete: () => {
              if (this.isOpen) {
                this.input.keyboard.manager.enabled = true
                this.input.mouse.enabled = true
              }
              transitionEventsEmitter.emit('end')
            },
          })

          this.isOpen = !this.isOpen
        }
      }

      class HUDScene extends Phaser.Scene {
        constructor() {
          super({ key: 'hud' })
        }

        create() {
          const graphics = this.make.graphics()
          if (!this.sys.game.device.os.desktop) {
            graphics.lineStyle(2, 0xffffff, 1)
            graphics.strokeRect(0, 0, 100, 100)
            graphics.fillStyle(0xffffff, 1)
            graphics.beginPath()
            graphics.moveTo(40, 40)
            graphics.lineTo(40, 60)
            graphics.lineTo(60, 50)
            graphics.closePath()
            graphics.fillPath()
            graphics.generateTexture('btnRight', 100, 100)
            graphics.clear()

            graphics.lineStyle(2, 0xffffff, 1)
            graphics.strokeRect(0, 0, 100, 100)
            graphics.fillStyle(0xffffff, 1)
            graphics.beginPath()
            graphics.moveTo(60, 40)
            graphics.lineTo(60, 60)
            graphics.lineTo(40, 50)
            graphics.closePath()
            graphics.fillPath()
            graphics.generateTexture('btnLeft', 100, 100)

            this.add.sprite(40, 420, 'btnLeft').setOrigin(0)
            this.add.sprite(160, 420, 'btnRight').setOrigin(0)
          }

          // Bouton pause
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillRect(10, 10, 8, 20)
          graphics.fillRect(22, 10, 8, 20)
          graphics.generateTexture('btnPause', 40, 40)
          graphics.clear()

          // Bouton play
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(10, 10)
          graphics.lineTo(10, 30)
          graphics.lineTo(30, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnPlay', 40, 40)
          graphics.clear()

          // Bouton restart
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(20, 10)
          graphics.lineTo(30, 20)
          graphics.lineTo(20, 30)
          graphics.lineTo(10, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnRestart', 40, 40)
          graphics.clear()

          // Bouton niveaux
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillRect(8, 8, 10, 10)
          graphics.fillRect(22, 8, 10, 10)
          graphics.fillRect(8, 22, 10, 10)
          graphics.fillRect(22, 22, 10, 10)
          graphics.generateTexture('btnLevels', 40, 40)
          graphics.destroy()

          const btnPause = this.add.sprite(900, 20, 'btnPause')
          btnPause.setOrigin(0).setInteractive()
          btnPause.on('pointerdown', this.togglePause, this)
          this.input.keyboard.on('keydown-P', this.togglePause, this)
          this.input.keyboard.on('keydown-ESC', this.togglePause, this)

          const isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          this.timerStarted = false
          this.startTime = 0
          const timerBg = this.add.rectangle(0, 20, 170, 40, 0x1d2b53, 0.5).setOrigin(0)
          this.timerText = this.add.text(20, 28, '00\'00"000', { fontSize: '24px', fill: '#ffffff' })
          const timerContainer = this.add.container(0, 0, [timerBg, this.timerText])
          timerContainer.setAlpha(isSpeedrunMode ? 1 : 0)
          const gameScene = this.scene.get('game')
          gameScene.events.on('startTimer', this.startTimer, this)
          gameScene.events.on('stopTimer', this.stopTimer, this)

          // Panel
          const { width, height } = this.scale
          const [panelWidth, panelHeight] = [320, 180]
          const [centerX, centerY] = [(width - panelWidth) / 2, (height - panelHeight) / 2]

          this.panelPause = this.add.container(0, 0)
          this.panelPause.setVisible(false)

          const panelOverlay = this.add.rectangle(0, 0, width, height, 0x1d2b53, 0.4)
          panelOverlay.setOrigin(0).setInteractive()

          const panelPauseBg = this.add.rectangle(centerX, centerY, panelWidth, panelHeight, 0x1d2b53).setOrigin(0)
          const panelTxt = this.add
            .text(width / 2, centerY + 20, 'PAUSE', { fontSize: '32px', fill: '#ffffff' })
            .setOrigin(0.5, 0)

          const btnPlay = this.add.sprite(width / 2, height / 2 + 20, 'btnPlay').setInteractive()
          btnPlay.on('pointerdown', this.togglePause, this)

          const btnRestart = this.add.sprite(width / 2 + 60, height / 2 + 20, 'btnRestart').setInteractive()
          btnRestart.on('pointerdown', this.restartCurrentLevel, this)

          const btnLevels = this.add.sprite(width / 2 - 60, height / 2 + 20, 'btnLevels').setInteractive()
          btnLevels.on('pointerdown', this.goToLevels, this)

          this.panelPause.add([panelOverlay, panelPauseBg, panelTxt, btnPlay, btnRestart, btnLevels])
        }

        goToLevels() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once(
            'end',
            () => {
              this.registry.set('isPaused', false)
              const gameScene = this.scene.get('game')
              gameScene.scene.start('levels')
            },
            this
          )
        }

        restartCurrentLevel() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once(
            'end',
            () => {
              this.registry.set('isPaused', false)
              this.scene.start('game')
              this.scene.restart('hud')
            },
            this
          )
        }

        togglePause() {
          const isPaused = this.registry.get('isPaused')
          if (isPaused) {
            this.scene.resume('game')
            this.pauseTime = this.time.now - this.pauseTime
            this.startTime += this.pauseTime
          } else {
            this.scene.pause('game')
            this.scene.get('game').resetPointers()
            this.pauseTime = this.time.now
          }

          this.panelPause.setVisible(!isPaused)
          this.registry.set('isPaused', !isPaused)
        }

        stopTimer(currentLevel) {
          const isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          if (!this.timerStarted || !isSpeedrunMode) return

          this.timerStarted = false

          if (!currentLevel) return

          const levelInfo = getLevelInfo(currentLevel)
          if (!levelInfo) return

          const previousBestTime = levelInfo.time || Infinity
          const newTime = this.time.now - this.startTime
          if (newTime < previousBestTime) {
            updateLevelInfo(currentLevel, { time: newTime })
          }

          this.startTime = 0
        }

        startTimer() {
          this.timerStarted = true
          this.startTime = this.time.now
        }

        update() {
          const isPaused = this.registry.get('isPaused')
          if (this.startTime === 0 || !this.timerStarted || isPaused) return
          const time = stringifyTime(this.time.now - this.startTime)
          this.timerText.setText(time)
        }
      }

      class IntroScene extends Phaser.Scene {
        constructor() {
          super({ key: 'intro' })
        }

        preload() {
          const mode = localStorage.getItem('mode') || 'classic'
          this.registry.set('mode', mode)

          const graphics = this.make.graphics()
          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.beginPath()
          graphics.moveTo(30, 10)
          graphics.lineTo(30, 30)
          graphics.lineTo(10, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('btnBack', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xffffff, 1)
          graphics.fillRect(0, 0, 40, 40)
          graphics.fillStyle(0x1d2b53, 1)
          graphics.fillTriangle(5, 27.5, 35, 27.5, 20, 5)
          graphics.generateTexture('btnSettings', 40, 40)
          graphics.destroy()
        }

        create() {
          const btnSettings = this.add.sprite(900, 20, 'btnSettings')
          btnSettings.setOrigin(0).setInteractive()
          btnSettings.on('pointerdown', this.goToSettings, this)

          const text = this.add
            .text(
              480,
              460,
              `${this.sys.game.device.os.desktop ? "Appuie sur la touche 'ESPACE'" : "Touche l'écran"} pour commencer`,
              { fontSize: '24px', fill: '#1d2b53' }
            )
            .setOrigin(0.5, 0.5)

          this.tweens.add({
            targets: text,
            duration: 1000,
            alpha: 0,
            repeat: -1,
            yoyo: true,
          })

          this.add
            .text(480, 200, 'BOBBY', {
              fontSize: '128px',
              fill: '#1d2b53',
            })
            .setOrigin(0.5, 0.5)

          this.add
            .text(480, 280, 'Titre à définir...', {
              fontSize: '24px',
              fill: '#1d2b53',
            })
            .setOrigin(0.5, 0.5)

          this.input.keyboard.on('keydown-SPACE', this.startGame, this)
          this.input.on('pointerdown', this.startGame, this)

          this.scene.launch('transition')
          this.scene.launch('audio')
        }

        goToSettings(pointer, localX, localY, event) {
          event.stopPropagation()
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('settings'), this)
        }

        startGame() {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start('levels'), this)
        }
      }

      class LevelsScene extends Phaser.Scene {
        constructor() {
          super({ key: 'levels' })
        }

        create() {
          this.scene.stop('hud')
          this.registry.set('isCheckpointActive', false)
          const unlockedLevels = getUnlockedLevels()

          const btnBack = this.add.sprite(40, 40, 'btnBack')
          btnBack.setInteractive()
          btnBack.on('pointerdown', () => this.goToScreen('intro'))

          // Niveaux
          const buttonOffset = 48
          const buttonSize = 80
          const buttonsPerCol = 2
          const buttonsPerRow = Math.ceil(NUM_LEVELS / buttonsPerCol)

          const totalButtonsWidth = (buttonSize + buttonOffset) * (buttonsPerRow - 1)
          const totalButtonsHeight = (buttonSize + buttonOffset) * (buttonsPerCol - 1)
          const startX = this.cameras.main.centerX - totalButtonsWidth / 2
          const startY = this.cameras.main.centerY - totalButtonsHeight / 2

          for (let i = 0; i < NUM_LEVELS; i++) {
            const level = i + 1
            const col = Math.floor(i / buttonsPerCol)
            const row = i % buttonsPerCol
            const direction = i % 2 ? 1 : -1

            const x = startX + col * (buttonSize + buttonOffset) + ((buttonSize + buttonOffset) / 4) * direction
            const y = startY + row * (buttonSize + buttonOffset) - ((buttonSize + buttonOffset) / 4) * direction
            const timePosY = y + buttonSize * direction

            const button = this.add.rectangle(x, y, buttonSize, buttonSize, 0x1d2b53)

            const levelInfo = getLevelInfo(level)
            button.rotation = Phaser.Math.DegToRad(45)

            if (levelInfo) {
              button.setInteractive()
              button.on('pointerdown', () => this.goToScreen('game', { level }))
            } else {
              button.alpha = 0.5
            }

            const time = (levelInfo && levelInfo.time) || 0
            const mode = this.registry.get('mode')
            if (time && mode === 'speedrun') {
              this.add.rectangle(x, timePosY, 100, 30, 0xffffff).setOrigin(0.5)
              this.add
                .text(x, timePosY, time ? stringifyTime(levelInfo.time) : '10\'00"00', {
                  color: '#1d2b53',
                  fontSize: '16px',
                })
                .setOrigin(0.5)
            }

            this.add.text(x, y, (i + 1).toString(), { color: '#ffffff', fontSize: '32px' }).setOrigin(0.5)
          }

          this.scene.launch('transition')
        }

        goToScreen(screen, params = {}) {
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.start(screen, params), this)
        }
      }

      class GameScene extends Phaser.Scene {
        constructor() {
          super({ key: 'game' })
        }

        init(data) {
          this.currentLevel = data.level
          this.levelData = levelsData[`level${this.currentLevel}`]
        }

        preload() {
          const graphics = this.make.graphics()
          graphics.fillStyle(0x000000, 1)
          graphics.fillRect(0, 0, 10, 10)
          graphics.generateTexture('particle', 10, 10)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.fillCircle(10, 10, 10)
          graphics.generateTexture('particleJump', 20, 20)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.beginPath()
          graphics.moveTo(0, 40)
          graphics.lineTo(20, 0)
          graphics.lineTo(40, 40)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('spike', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xc2c3c7, 1)
          graphics.beginPath()
          graphics.moveTo(20, 1)
          graphics.lineTo(39, 20)
          graphics.lineTo(20, 39)
          graphics.lineTo(1, 20)
          graphics.closePath()
          graphics.fillPath()
          graphics.fillStyle(0x000000, 1)
          graphics.fillCircle(20, 20, 15)
          graphics.generateTexture('spikyBall', 40, 40)
          graphics.clear()

          graphics.fillStyle(0xffffff, 1)
          graphics.fillCircle(30, 30, 30)
          graphics.fillCircle(50, 50, 30)
          graphics.fillCircle(70, 30, 30)
          graphics.fillCircle(90, 50, 30)
          graphics.fillCircle(120, 30, 30)
          graphics.generateTexture('cloud', 150, 120)
          graphics.clear()

          graphics.fillStyle(0x008751, 1)
          graphics.beginPath()
          graphics.moveTo(0, 800)
          graphics.lineTo(400, 0)
          graphics.lineTo(800, 800)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('hill', 800, 800)
          graphics.clear()

          graphics.fillStyle(0x5f574f, 1)
          graphics.beginPath()
          graphics.moveTo(0, 800)
          graphics.lineTo(400, 0)
          graphics.lineTo(800, 800)
          graphics.closePath()
          graphics.fillPath()
          graphics.generateTexture('hill2', 800, 800)
          graphics.destroy()
        }

        create() {
          this.canMove = false
          this.isReady = false
          this.touchLeft = false
          this.touchRight = false
          this.timerStarted = false
          this.isCheckpointActive = this.registry.get('isCheckpointActive')
          this.isSpeedrunMode = this.registry.get('mode') === 'speedrun'
          this.audioManager = this.scene.get('audio')
          this.time.delayedCall(
            500,
            () => {
              this.isReady = true
            },
            [],
            this
          )
          this.isUpKeyPressed = false
          this.isTransitionning = false
          this.playerWasStanding = false
          this.worldWidth = this.levelData.world.width
          this.worldHeight = this.levelData.world.height
          this.physics.world.setBounds(0, 0, this.worldWidth, this.worldHeight)

          const hillsPos = this.levelData.hills ?? []
          this.hills = this.add.group()
          for (let i = 0; i < hillsPos.length; i++) {
            let hill = this.hills.create(hillsPos[i].x, hillsPos[i].y, 'hill')
            hill.setOrigin(0)
            hill.setScrollFactor(0.3)
          }

          const hillsPos2 = this.levelData.hillsFront ?? []
          this.hills2 = this.add.group()
          for (let i = 0; i < hillsPos2.length; i++) {
            let hill = this.hills2.create(hillsPos2[i].x, hillsPos2[i].y, 'hill2')
            hill.setOrigin(0)
            hill.setScrollFactor(0.4)
          }

          const cloudsPos = this.levelData.clouds?.x ?? []
          this.clouds = this.physics.add.group({
            allowGravity: false,
          })
          for (let i = 0; i < cloudsPos.length; i++) {
            let cloud = this.clouds.create(
              cloudsPos[i],
              Phaser.Math.Between(this.levelData.clouds.y.min, this.levelData.clouds.y.max),
              'cloud'
            )
            cloud.setVelocityX(Phaser.Math.Between(10, 20))
            cloud.setAlpha(Phaser.Math.FloatBetween(0.2, 0.8))
          }

          // Plateformes
          this.platforms = this.physics.add.staticGroup()
          const platformsPos = this.levelData.platforms || []
          for (let i = 0; i < platformsPos.length; i++) {
            const { x, y, width, height } = platformsPos[i]
            this.addPlatform(this.platforms, x, y, width, height)
          }

          // Plateformes à sens unique
          this.oneWayPlatforms = this.physics.add.group({
            allowGravity: false,
            immovable: true,
          })
          const oneWayPlatformsPos = this.levelData.oneWayPlatforms || []
          for (let i = 0; i < oneWayPlatformsPos.length; i++) {
            this.addOneWayPlatform(this.oneWayPlatforms, oneWayPlatformsPos[i])
          }

          // Créer le téléporteur et les particules
          const particles = this.add.particles(this.levelData.target.x, this.levelData.target.y, 'particle', {
            speed: { min: -100, max: 100 },
            angle: { min: 0, max: 360 },
            scale: { start: 1, end: 0 },
            lifespan: 1000,
            frequency: 100,
            quantity: 5,
          })

          this.target = this.add.circle(this.levelData.target.x, this.levelData.target.y, 20, 0x1d2b53)
          this.physics.add.existing(this.target, true)
          this.target.body.setCircle(40)
          this.target.body.setOffset(-20, -20)

          // Pics
          const spikes = this.physics.add.staticGroup()
          const spikesPos = this.levelData.spikes ?? []
          for (let i = 0; i < spikesPos.length; i++) {
            const { x, y } = spikesPos[i]
            this.addSpike(spikes, x, y)
          }

          const spikyBalls = this.physics.add.staticGroup()
          const spikyBallsPos = this.levelData.spikyBalls ?? []
          for (let i = 0; i < spikyBallsPos.length; i++) {
            this.addspikyBall(spikyBalls, spikyBallsPos[i])
          }

          // Plateformes sensibles
          this.fallingBlocks = this.physics.add.staticGroup()
          this.fallingBlocksTriggers = this.physics.add.staticGroup()
          const fallingBlocksPos = this.levelData.fallingBlocks ?? []
          for (let i = 0; i < fallingBlocksPos.length; i++) {
            const { x, y } = fallingBlocksPos[i]
            this.addFallingBlock(this.fallingBlocks, this.fallingBlocksTriggers, x, y)
          }

          // Ennemis
          this.enemies = this.physics.add.group()
          const enemiesPos = this.levelData.enemies ?? []
          for (let i = 0; i < enemiesPos.length; i++) {
            const { x, y, dir } = enemiesPos[i]
            const enemy = this.add.rectangle(x, y, 40, 40, 0xff004d)
            enemy.setData('dir', dir ?? 1)
            this.physics.add.existing(enemy)
            this.enemies.add(enemy)
          }

          // Checkpoint
          if (this.levelData.checkpoint && !this.isSpeedrunMode) {
            const pole = this.add.rectangle(0, 0, 10, 120, 0xc2c3c7)
            this.checkpointFlag = this.add
              .triangle(45, pole.height / 2 - 4 - (this.isCheckpointActive ? 60 : 0), 0, -20, 40, 0, 0, 20, 0xffa300)
              .setOrigin(1, 0.5)
            this.checkpoint = this.add.container(this.levelData.checkpoint.x, this.levelData.checkpoint.y, [
              pole,
              this.checkpointFlag,
            ])
            this.physics.add.existing(this.checkpoint, true)
            this.checkpoint.body.setSize(pole.width, pole.height)
            this.checkpoint.body.setOffset(26, -28)
          }

          // Créer le joueur
          const startingPos = this.isCheckpointActive
            ? { x: this.levelData.checkpoint.x - 40, y: this.levelData.checkpoint.y }
            : this.levelData.player
          this.player = this.add.container(startingPos.x, startingPos.y)
          this.playerSprite = this.add.rectangle(0, 0, 40, 40, 0xfff1e8)
          this.player.add(this.playerSprite)
          this.player.setSize(40, 40)
          this.physics.world.enable(this.player)
          this.jumpCount = 0
          this.playerDir = 1
          this.prevVelocityY = 0

          this.playerShadowHitbox = this.add.rectangle(
            this.levelData.player.x,
            this.levelData.player.y,
            40,
            40,
            0xfff1e8,
            0
          )
          this.physics.add.existing(this.playerShadowHitbox, true)

          // Particules du joueur lors du saut
          this.playerEmitter = this.add.particles(0, 0, 'particleJump', {
            lifespan: 300,
            speedX: { min: -100, max: 100 },
            speedY: 0,
            scale: { start: 1, end: 0 },
            emitting: false,
            quantity: 5,
          })

          // Mort du joueur
          this.physics.add.overlap(this.player, spikes, this.die, undefined, this)
          this.physics.add.overlap(this.player, spikyBalls, this.die, undefined, this)
          this.enemiesCollider = this.physics.add.overlap(
            this.enemies,
            this.player,
            this.handleEnemiesCollision,
            undefined,
            this
          )

          // Ajouter la collision entre le joueur, les ennemis et le sol
          this.platformsCollider = this.physics.add.collider(this.player, this.platforms)
          this.oneWayPlatformsCollider = this.physics.add.collider(
            this.player,
            this.oneWayPlatforms,
            this.stickPlayerToPlatform,
            null,
            this
          )
          this.physics.add.collider(this.enemies, this.platforms)
          this.physics.add.collider(this.enemies, this.oneWayPlatforms)
          this.physics.add.collider(this.enemies, this.fallingBlocks)
          this.fallingBlocksCollider = this.physics.add.collider(this.player, this.fallingBlocks)
          this.fallingBlocksTriggers = this.physics.add.overlap(
            this.player,
            this.fallingBlocksTriggers,
            this.handleFallingBlockCollision,
            undefined,
            this
          )

          // Détection checkpoint
          if (this.levelData.checkpoint && !this.isCheckpointActive) {
            this.physics.add.overlap(this.player, this.checkpoint, this.handleCheckpoint, null, this)
          }

          // Detection de fin de jeu
          this.targetTrigger = this.physics.add.overlap(this.player, this.target, this.teleport, undefined, this)

          // Suivi de la caméra
          this.cameras.main.startFollow(this.player, true, 0.1, 0.1)
          this.cameras.main.setBounds(0, 0, this.worldWidth, this.worldHeight)

          // Créer les contrôles
          this.cursors = this.input.keyboard.createCursorKeys()
          this.keys = this.input.keyboard.addKeys('Q,D')
          this.zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z)
          this.upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP)
          this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE)
          this.input.keyboard.on('keyup-UP', this.resetJump, this)
          this.input.keyboard.on('keyup-Z', this.resetJump, this)
          this.input.keyboard.on('keydown-R', this.handlRestartToggle, this)

          // Mobiles
          if (!this.sys.game.device.os.desktop) {
            // Pointers
            this.input.on('pointerdown', this.handlePointerDown, this)
            this.input.on('pointermove', this.handlePointerMove, this)
            this.input.on('pointerup', this.handlePointerUp, this)
          }

          // Limite horizontale du monde
          this.events.on('postupdate', this.checkWorldBounds, this)
          this.events.once('shutdown', () => {
            this.events.off('postupdate', this.checkWorldBounds)
          })

          // HUD
          this.scene.launch('hud')

          // Transition
          this.scene.launch('transition')
        }

        update(time, delta) {
          const justTriggeredJump =
            Phaser.Input.Keyboard.JustDown(this.zKey) ||
            Phaser.Input.Keyboard.JustDown(this.upKey) ||
            Phaser.Input.Keyboard.JustDown(this.spaceKey)

          const isGoingLeft = this.cursors.left.isDown || this.keys.Q.isDown || this.touchLeft
          const isGoingRight = this.cursors.right.isDown || this.keys.D.isDown || this.touchRight

          // Check du premier mouvement pour déclencher le timer
          if (justTriggeredJump || isGoingLeft || isGoingRight) this.checkFirstMove()

          // Mouvement des ennemis
          this.enemies
            .getChildren()
            .filter((enemy) => !enemy.getData('isDead'))
            .forEach((enemy) => {
              let dir = enemy.getData('dir')
              if (enemy.body.touching.right) {
                dir = -1
              } else if (enemy.body.touching.left) {
                dir = 1
              }
              enemy.setData('dir', dir)
              enemy.body.setVelocityX(ENEMY_VELOCITY * dir)
            })

          // Reset des nuages
          this.clouds.children.iterate((cloud) => {
            if (cloud.x > this.physics.world.bounds.width) {
              cloud.x = -120
            }
          })

          // Plateformes mobiles
          this.handleMovingPlatforms(time, delta)

          if (!this.canMove) return

          if (this.player.body.velocity.y !== 0) {
            this.prevVelocityY = this.player.body.velocity.y
          }

          // Réinitialiser la vitesse horizontale du joueur
          if (this.player.body.velocity.x !== 0) {
            this.playerDir = Math.sign(this.player.body.velocity.x)
          }
          this.player.body.setVelocityX(0)

          // Gérer les mouvements à gauche et à droite
          if (isGoingLeft) {
            this.player.body.setVelocityX(-PLAYER_VELOCITY + (this.stickedVelocityX < 0 ? this.stickedVelocityX : 0))
          } else if (isGoingRight) {
            this.player.body.setVelocityX(PLAYER_VELOCITY + (this.stickedVelocityX > 0 ? this.stickedVelocityX : 0))
          }

          // Z Bug, appel multiple de jump avec les events
          if (justTriggeredJump) {
            this.jump()
          }

          // Détection de chute pour coyote time
          if (this.playerWasStanding && !this.player.body.blocked.down) {
            this.playerWasStanding = false
            this.fallStartTime = this.time.now
          } else if (
            !this.playerWasStanding &&
            this.jumpCount === 0 &&
            this.time.now - this.fallStartTime >= PLAYER_COYOTE_TIME
          ) {
            this.jumpCount = 1
          } else if (!this.playerWasStanding && this.player.body.blocked.down && !justTriggeredJump) {
            this.playerWasStanding = true
            this.jumpCount = 0

            if (this.prevVelocityY >= PLAYER_FALL_SQUASH_VELOCITY) {
              this.completePlayerTweens()
              this.playerEmitter.emitParticleAt(this.player.x, this.player.y + 24)
              this.tweens.add({
                targets: this.playerSprite,
                scaleY: 0.6,
                scaleX: 1.4,
                y: 8,
                duration: 150,
                yoyo: true,
                ease: 'Cubic.easeOut',
              })
            }
          }

          // Jump buffering
          if (
            this.isUpKeyPressed &&
            this.player.body.blocked.down &&
            time - this.jumpBufferingTime < PLAYER_BUFFERING_TIME
          ) {
            this.jump()
          }

          // Gérer le saut progressif
          if (this.isJumping && this.isUpKeyPressed) {
            let pressDuration = time - this.jumpStartTime
            if (pressDuration > PLAYER_MAX_JUMP_TIME) {
              this.isJumping = false
              pressDuration = PLAYER_MAX_JUMP_TIME
            }

            const t = pressDuration / PLAYER_MAX_JUMP_TIME
            const jumpVelocity =
              PLAYER_MIN_JUMP_VELOCITY + (PLAYER_MAX_JUMP_VELOCITY - PLAYER_MIN_JUMP_VELOCITY) * Math.pow(t, 2)
            this.player.body.setVelocityY(jumpVelocity)
          }

          // Sortie du monde
          if (this.player.y - this.player.body.height / 2 > this.physics.world.bounds.height) {
            this.die.call(this)
          }
        }

        checkWorldBounds() {
          const playerHalfWidth = this.player.body.width / 2
          if (this.player.x - playerHalfWidth < 0) {
            this.player.x = playerHalfWidth
          } else if (this.player.x + playerHalfWidth > this.physics.world.bounds.width) {
            this.player.x = this.physics.world.bounds.width - playerHalfWidth
          }
        }

        startTimer() {
          this.timerStarted = true
          this.canMove = true
          this.events.emit('startTimer')
        }

        handlePointerDown(pointer) {
          // Saut lors du touch sur la zone droite de l'écran
          if (pointer.x > 480) {
            this.checkFirstMove()
            this.jump()
          }

          this.handlePointerMove(pointer)
        }

        handlePointerMove(pointer) {
          if (pointer.x < 150) {
            this.touchRight = false
            this.touchLeft = true
          } else if (pointer.x < 300) {
            this.touchRight = true
            this.touchLeft = false
          }
        }

        handlePointerUp(pointer) {
          if (pointer.x > 300) return
          this.resetPointers()
        }

        resetPointers() {
          this.touchLeft = false
          this.touchRight = false
        }

        checkFirstMove() {
          if (!this.isReady || this.timerStarted) return
          this.startTimer()
        }

        resetJump() {
          if (!this.canMove) return
          this.isUpKeyPressed = false
          this.isJumping = false
        }

        jump() {
          if (!this.canMove) return
          this.isUpKeyPressed = true

          const shouldDoubleJump =
            !this.player.body.blocked.down && this.jumpCount > 0 && this.jumpCount < PLAYER_MAX_JUMPS
          let playerAlmostLanded = false
          if (shouldDoubleJump && this.player.body.velocity.y > 0) {
            playerAlmostLanded = this.checkPlayerRightAbovePlatform()
          }

          if (
            this.player.body.blocked.down ||
            (!this.player.body.blocked.down &&
              this.time.now - this.fallStartTime < PLAYER_COYOTE_TIME &&
              this.jumpCount === 0) ||
            (shouldDoubleJump && !playerAlmostLanded)
          ) {
            this.jumpCount++
            this.isJumping = true
            this.jumpStartTime = this.time.now
            this.completePlayerTweens()
            this.audioManager.playSfx('sfxJump')

            if (this.jumpCount === 1) {
              this.tweens.add({
                targets: this.playerSprite,
                scaleY: 1.4,
                scaleX: 0.6,
                y: -8,
                duration: 200,
                yoyo: true,
                ease: 'Cubic.easeOut',
              })
            } else {
              this.playerEmitter.emitParticleAt(this.player.x, this.player.y + 24)
              this.tweens.add({
                targets: this.playerSprite,
                angle: 360 * this.playerDir,
                duration: 600,
                ease: 'Cubic.easeOut',
                onComplete: () => {
                  this.player.angle = 0
                },
              })
            }
          } else {
            this.jumpBufferingTime = this.time.now
          }
        }

        checkPlayerRightAbovePlatform() {
          const platformsToCheck = [
            ...this.platforms.getChildren(),
            ...this.oneWayPlatforms.getChildren(),
            ...this.fallingBlocks.getChildren(),
          ]
          this.playerShadowHitbox.x = this.player.x
          this.playerShadowHitbox.y = this.player.y + 40
          this.playerShadowHitbox.body.updateFromGameObject()
          return this.physics.overlap(this.playerShadowHitbox, this.platforms)
        }

        teleport() {
          this.canMove = false
          this.player.body.enable = false
          this.events.emit('stopTimer', this.currentLevel)
          this.audioManager.playSfx('sfxWin')

          if (this.currentLevel < NUM_LEVELS && this.currentLevel < Object.keys(levelsData).length) {
            unlockLevel(this.currentLevel + 1)
          }

          const timeline = this.add.timeline([
            {
              at: 0,
              tween: {
                targets: this.playerSprite,
                angle: 540 * this.playerDir,
                delay: 200,
                duration: 600,
                scale: 0.5,
                x: this.target.x - this.player.x,
                y: this.target.y - this.player.y,
              },
            },
            {
              at: 1200,
              tween: {
                targets: this.playerSprite,
                duration: 300,
                scale: 0,
                alpha: 0,
                ease: 'Cubic.In',
              },
            },
            {
              at: 900,
              tween: {
                targets: this.target,
                duration: 300,
                scale: 1.6,
                ease: 'Cubic.Out',
              },
            },
            {
              at: 1200,
              tween: {
                targets: this.target,
                duration: 300,
                scale: 0,
                ease: 'Cubic.In',
                onComplete: () => {
                  transitionEventsEmitter.emit('start')
                  transitionEventsEmitter.once('end', () => this.scene.start('levels'), this)
                },
              },
            },
          ])
          timeline.play()
        }

        die() {
          if (this.player.getData('isDead')) return
          this.player.setData('isDead', true)
          this.canMove = false
          this.platformsCollider.active = false
          this.oneWayPlatformsCollider.active = false
          this.enemiesCollider.active = false
          this.fallingBlocksCollider.active = false
          this.fallingBlocksTriggers.active = false
          this.targetTrigger = false
          this.cameras.main.stopFollow()
          this.audioManager.playSfx('sfxDeath')
          this.events.emit('stopTimer')
          this.player.body.setVelocity(PLAYER_DEATH_JUMP_X * this.playerDir * -1, PLAYER_DEATH_JUMP_Y)
          this.time.delayedCall(1000, this.lose, [], this)
        }

        handlRestartToggle() {
          if (this.player.getData('isDead')) return
          this.restartGame()
        }

        restartGame() {
          if (this.isTransitionning) return

          this.isTransitionning = true
          transitionEventsEmitter.emit('start')
          transitionEventsEmitter.once('end', () => this.scene.restart(), this)
        }

        lose() {
          this.restartGame()
        }

        addPlatform(group, x, y, width, height) {
          const platform = this.add.rectangle(x, y, width, height, 0xab5236)
          platform.setOrigin(0)
          group.add(platform)
        }

        addOneWayPlatform(group, data) {
          const { x, y, width, points } = data
          const platform = this.add.rectangle(x, y, width, 20, 0xffccaa)
          platform.setOrigin(0)
          group.add(platform)
          platform.body.checkCollision.down = false
          platform.body.checkCollision.left = false
          platform.body.checkCollision.right = false

          if (!points) return
          const path = new Phaser.Curves.Path(x, y)
          for (let i = 0; i < points.length; i++) {
            path.lineTo(points[i].x, points[i].y)
          }

          path.lineTo(x, y)
          platform.setData('isMoving', true)
          platform.setData('follower', {
            path,
            t: 0,
            vec: new Phaser.Math.Vector2(),
          })
        }

        stickPlayerToPlatform(player, platform) {
          if (!platform.getData('isMoving') || player.getData('stickedPlafform')) return
          player.setData('stickedPlatform', platform)
        }

        addSpike(group, x, y) {
          const spike = this.add.sprite(x, y, 'spike')
          spike.setOrigin(0)
          this.physics.add.existing(spike, true)
          spike.body.setCircle(spike.displayWidth / 3)
          spike.body.setOffset(spike.displayWidth / 6, spike.displayHeight / 3)
          group.add(spike)
        }

        addspikyBall(group, data) {
          const { x, y } = data
          const spikyBall = this.add.sprite(x, y, 'spikyBall')
          spikyBall.setOrigin(0)
          this.physics.add.existing(spikyBall, true)
          spikyBall.body.setCircle(20)
          group.add(spikyBall)
        }

        addFallingBlock(group, triggerGroup, x, y) {
          const fallingBlock = this.add.rectangle(x + 1, y, 38, 38, 0x5f574f)
          fallingBlock.setOrigin(0)
          group.add(fallingBlock)
          const trigger = this.add.rectangle(x, y - 1, 40, 42)
          trigger.setOrigin(0)
          trigger.setData('block', fallingBlock)
          triggerGroup.add(trigger)
        }

        handleFallingBlockCollision(player, fallingBlockTrigger) {
          const fallingBlock = fallingBlockTrigger.getData('block')
          if (!player.body.blocked.down || fallingBlockTrigger.getData('isTriggered')) return
          fallingBlockTrigger.setData('isTriggered', true)

          this.tweens.add({
            targets: fallingBlock,
            duration: 80,
            repeat: 4,
            yoyo: true,
            ease: 'Bounce.easeInOut',
            x: fallingBlock.x + 2,
            onComplete: () => {
              fallingBlock.body.enable = false
              this.tweens.add({
                targets: fallingBlock,
                y: fallingBlock.y + 40,
                alpha: 0,
                duration: 300,
                onComplete: () => {
                  fallingBlock.destroy()
                },
              })
            },
          })
        }

        handleEnemiesCollision(player, enemy) {
          if (this.player.getData('isDead') || enemy.getData('isDead')) return

          const dx = player.x - enemy.x
          const dy = player.y - enemy.y

          const angle = Math.atan2(dy, dx)
          const angleDeg = Phaser.Math.RadToDeg(angle)

          if (angleDeg <= -45 && angleDeg >= -135) {
            enemy.setData('isDead', true)
            enemy.body.setVelocityX(0)

            this.tweens.add({
              targets: enemy,
              duration: 300,
              scale: 0,
              ease: 'Back.In',
              onComplete: () => {
                enemy.destroy()
              },
            })

            player.body.setVelocityY(-PLAYER_BOUNCE_OFF_VELOCITY)
            this.jumpCount = 1
            this.isJumping = true
            this.jumpStartTime = this.time.now
            this.isUpKeyPressed = false
            this.playerWasStanding = true
            this.audioManager.playSfx('sfxHit')

            return
          }

          this.die.call(this)
        }

        completePlayerTweens() {
          this.tweens.killTweensOf(this.playerSprite)
          this.playerSprite.setScale(1)
          this.playerSprite.angle = 0
          this.playerSprite.y = 0
        }

        handleCheckpoint() {
          if (this.isCheckpointActive && !this.player.getData('isDead')) return
          this.isCheckpointActive = true
          this.registry.set('isCheckpointActive', true)

          this.audioManager.playSfx('sfxCheckpoint')
          this.tweens.add({
            targets: this.checkpointFlag,
            y: this.checkpointFlag.y - 60,
            duration: 1000,
            ease: 'Cubic.Out',
          })
        }

        handleMovingPlatforms(time, delta) {
          // Reset du stick plateforme
          this.stickedPlatform = this.player.getData('stickedPlatform')
          this.stickedVelocityX = 0
          if (this.stickedPlatform && !this.player.body.touching.down) {
            this.stickedPlatform = null
            this.player.setData('stickedPlatform', null)
          }

          this.oneWayPlatforms
            .getChildren()
            .filter((platform) => platform.getData('isMoving'))
            .forEach((platform) => {
              const previousX = platform.x
              const follower = platform.getData('follower')
              follower.path.getPoint(follower.t, follower.vec)
              const deltaX = follower.vec.x - platform.x
              const deltaY = follower.vec.y - platform.y
              platform.setPosition(follower.vec.x, follower.vec.y)
              follower.t += delta / 5000
              if (follower.t >= 1) {
                follower.t = 0
              }

              // Déplacement du joueur avec la plateforme
              if (this.stickedPlatform === platform) {
                this.player.y += deltaY
                this.stickedVelocityX = (platform.x - previousX) / (delta / 1000)
                if (this.player.body.velocity.x === 0) {
                  this.player.x += deltaX

                  // Détection à la main des collisions
                  if (
                    this.player.x - this.player.body.halfWidth < this.stickedPlatform.x ||
                    this.player.x + this.player.body.halfWidth > this.stickedPlatform.x
                  ) {
                    const x =
                      this.stickedVelocityX > 0
                        ? this.player.x + this.player.body.halfWidth
                        : this.player.x - this.player.body.halfWidth - 10
                    const rectDetection = new Phaser.Geom.Rectangle(x, this.player.y, 10, this.player.body.halfHeight)
                    const collidingPlatforms = this.platforms
                      .getChildren()
                      .filter((platform) =>
                        Phaser.Geom.Intersects.RectangleToRectangle(rectDetection, platform.getBounds())
                      )

                    if (collidingPlatforms.length) {
                      const platformToCheck = collidingPlatforms[0]
                      if (this.stickedVelocityX > 0 && this.player.x + this.player.body.halfWidth > platformToCheck.x) {
                        this.player.x = platformToCheck.x - this.player.body.halfWidth
                      } else if (
                        this.stickedVelocityX < 0 &&
                        this.player.x - this.player.body.halfWidth < platformToCheck.x + platformToCheck.width
                      ) {
                        this.player.x = platformToCheck.x + platformToCheck.width + this.player.body.halfWidth
                      }
                    }
                  }
                }
              }
            })
        }
      }

      const config = {
        type: Phaser.AUTO,
        backgroundColor: '#29ADFF',
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: 960,
          height: 540,
        },
        physics: {
          default: 'arcade',
          arcade: {
            gravity: {
              y: 1600,
            },
          },
        },
        input: {
          activePointers: 3,
        },
        scene: [
          PreloaderScene,
          IntroScene,
          LevelsScene,
          GameScene,
          HUDScene,
          TransitionScene,
          AudioScene,
          SettingsScene,
        ],
      }

      const game = new Phaser.Game(config)
    </script>
  </body>
</html>
